import express from 'express'
import cors from 'cors'
import { config } from 'dotenv'
import pkg from 'systeminformation';
import prettyBytes from 'pretty-bytes'
const si = pkg;

const HTMLheader = `<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>Server status</title>
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<style>
		body {
			margin: 20px;
			padding: 20px;
		}
	</style>
</head>
<body>`
const HTMLfooter = `
</body>
</html>`

// Load environment variables from .env file
config()

const app = express()
const PORT = process.env.PORT || 3001

// Middleware
app.use(cors())
app.use(express.json())

// Bedrock configuration from environment variables
const region = process.env.AWS_REGION || 'eu-west-2'
const bedrockApiKey = process.env.BEDROCK_API_KEY
const modelId = process.env.MODEL_ID || 'eu.anthropic.claude-haiku-4-5-20251001-v1:0'

if (!bedrockApiKey) {
	console.error('ERROR: BEDROCK_API_KEY environment variable is not set')
	process.exit(1)
}

// Proxy endpoint for Bedrock chat
app.post('/api/chat', async (req, res) => {
	try {
		const { message, systemPrompt } = req.body

		if (!message) {
			return res.status(400).json({ error: 'Message is required' })
		}

		const conversation = [
			{
				role: 'user',
				content: [{ text: message }],
			},
		]

		const payload = {
			modelId,
			messages: conversation,
			system: systemPrompt || [
				{
					text: `
			"#### _This text has been generated by AI._". 
			Format your answer using Markdown. `,
				},
			],
			inferenceConfig: { maxTokens: 512, temperature: 0.5 },
		}

		const url = `https://bedrock-runtime.${region}.amazonaws.com/model/${modelId}/converse`
		const response = await fetch(url, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				Authorization: `Bearer ${bedrockApiKey}`,
			},
			body: JSON.stringify(payload),
		})

		if (!response.ok) {
			const errorText = await response.text()
			console.error('Bedrock API error:', errorText)
			return res.status(response.status).json({ error: errorText })
		}

		const data = await response.json()
		const responseText = data.output.message.content[0].text

		res.json({ response: responseText })
	} catch (error) {
		console.error('Server error:', error)
		res.status(500).json({ error: error.message })
	}
})

//proxy endpoint for system status
app.get('/api/status', async (req, res) => {
	try {
		const systemMem = await si.mem()
		const systemLoad = await si.currentLoad()
		const systemInfo = await si.system()
		const osInfo = await si.osInfo()

		res.send(`${HTMLheader}
		<h2>${systemInfo.manufacturer} ${systemInfo.model}, OS: ${osInfo.distro} ${osInfo.release}</h2>
		<p>
		Total memory: ${prettyBytes(systemMem.total)}<br>
		Free memory: ${prettyBytes(systemMem.free)}<br>
		Available memory: ${prettyBytes(systemMem.available)}
		<p>
		Swap total: ${prettyBytes(systemMem.swaptotal)}<br>
		Swap used: ${prettyBytes(systemMem.swapused)}<br>
		Swap free: ${prettyBytes(systemMem.swapfree)}
		<p>
		Current load (user): ${systemLoad.currentLoadUser.toFixed(2)}%<br>
		Current load (system): ${systemLoad.currentLoadSystem.toFixed(2)}%<br>
		Current load (idle): ${systemLoad.currentLoadIdle.toFixed(2)}%<br>
		${HTMLfooter}`)
	} catch (error) {
		console.error('Status endpoint error:', error)
		res.status(500).json({ error: error.message })
	}
})

app.listen(PORT, () => {
	console.log(`Proxy server running on http://localhost:${PORT}`)
})
