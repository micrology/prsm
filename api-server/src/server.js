/********************************server.js***********************
 * Express server that acts as a proxy to the Bedrock API
 * 
 * Exposes an endpoint /api/chat that accepts POST requests with a user message
 * and optional system prompt, forwards them to Bedrock, and returns the response.
 * 
 * Requires the following environment variables:
 * - BEDROCK_API_KEY: Your Bedrock API key
 * - AWS_REGION: AWS region where Bedrock is hosted (default: eu-west-2)
 * - MODEL_ID: Bedrock model ID to use (default: eu.anthropic.claude-haiku-4-5-20251001-v1:0)
 * 
 * For Bedrock access, also requires the PRSM room requesting access
 * 
 * Also exposes a /api/status endpoint that returns basic system information.
 * 
 * Run this as a service: prsm-api-server.service:
 * 
 * /etc/systemd/system/prsm-api-server.service

[Unit]
Description=PRSM API Server
After=network.target

[Service]
Type=simple
User=ec2-user
WorkingDirectory=/data/cress/prsm/api-server
ExecStart=/usr/local/bin/npm run server
Restart=always
RestartSec=10
StandardOutput=journal
StandardError=journal
SyslogIdentifier=prsm-api-server

[Install]
WantedBy=multi-user.target

for status, use:
journalctl -f -u prsm-api-server
 ****************************************************************
 
 or locally
 
 npm run server
 or
 PORT=XXXX npm run server
 ***************************************************************

 http://server-domain:${PORT}/api/status

 shows the status of the server

 ****************************************************************/
import express from 'express'
import cors from 'cors'
import { config } from 'dotenv'
import pkg from 'systeminformation';
import prettyBytes from 'pretty-bytes'
import { WebsocketProvider } from 'y-websocket'
import * as Y from 'yjs'
import { createHttpTerminator } from 'http-terminator'

		const websocket = 'wss://www.prsm.uk/wss'

const si = pkg;

const HTMLheader = `<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>Server status</title>
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<style>
		body {
			margin: 20px;
			padding: 20px;
		}
	</style>
</head>
<body>`
const HTMLfooter = `
</body>
</html>`

// Load environment variables from .env file
config()

const app = express()
const PORT = process.env.PORT || 3001

// Middleware
app.use(cors())
app.use(express.json())

// Log all incoming requests
app.use((req, res, next) => {
	const url = new URL(req.url, `http://${req.headers.host}`)
	console.log(`Processing ${url.pathname} for room ${req.body.room || 'N/A'}`)
	next()
})

// Bedrock configuration from environment variables
const region = process.env.AWS_REGION || 'eu-west-2'
const bedrockApiKey = process.env.BEDROCK_API_KEY
const modelId = process.env.MODEL_ID || 'eu.anthropic.claude-haiku-4-5-20251001-v1:0'

if (!bedrockApiKey) {
	console.error('ERROR: BEDROCK_API_KEY environment variable is not set')
	process.exit(1)
}

// Proxy endpoint for Bedrock chat
app.post('/api/chat', async (req, res) => {
	try {
		const { message, systemPrompt, room } = req.body

		if (!room || !room.match(/[a-zA-Z]{3}-[a-zA-Z]{3}-[a-zA-Z]{3}-[a-zA-Z]{3}/)) {
			return res.status(400).json({ error: `Invalid room identifier: ${room}` })
		}
		if (!message) {
			return res.status(400).json({ error: 'Message is required' })
		}

		const conversation = [
			{
				role: 'user',
				content: [{ text: message }],
			},
		]

		const payload = {
			modelId,
			messages: conversation,
			system: [
				{
					text: `${systemPrompt}  ||
			"> ***This text has been generated by AI. It needs to be checked carefully.***". 
			Format your answer using Markdown. `,
				},
			],
			inferenceConfig: { maxTokens: 512, temperature: 0.5 },
		}

		const url = `https://bedrock-runtime.${region}.amazonaws.com/model/${modelId}/converse`
		const response = await fetch(url, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				Authorization: `Bearer ${bedrockApiKey}`,
			},
			body: JSON.stringify(payload),
		})

		if (!response.ok) {
			const errorText = await response.text()
			console.error('Bedrock API error:', errorText)
			return res.status(response.status).json({ error: errorText })
		}

		const data = await response.json()
		const responseText = data.output.message.content[0].text

		res.json({ response: responseText })
	} catch (error) {
		console.error('Server error:', error)
		res.status(500).json({ error: error.message })
	}
})

//proxy endpoint for system status
app.get('/api/status', async (req, res) => {
	try {
		const systemMem = await si.mem()
		const systemLoad = await si.currentLoad()
		const systemInfo = await si.system()
		const osInfo = await si.osInfo()

		res.send(`${HTMLheader}
		<h2>${systemInfo.manufacturer} ${systemInfo.model}, OS: ${osInfo.distro} ${osInfo.release}</h2>
		<p>
		Total memory: ${prettyBytes(systemMem.total)}<br>
		Free memory: ${prettyBytes(systemMem.free)}<br>
		Available memory: ${prettyBytes(systemMem.available)}
		<p>
		Swap total: ${prettyBytes(systemMem.swaptotal)}<br>
		Swap used: ${prettyBytes(systemMem.swapused)}<br>
		Swap free: ${prettyBytes(systemMem.swapfree)}
		<p>
		Current load (user): ${systemLoad.currentLoadUser.toFixed(2)}%<br>
		Current load (system): ${systemLoad.currentLoadSystem.toFixed(2)}%<br>
		Current load (idle): ${systemLoad.currentLoadIdle.toFixed(2)}%<br>
		${HTMLfooter}`)
	} catch (error) {
		console.error('Status endpoint error:', error)
		res.status(500).json({ error: error.message })
	}
})
app.post('/api/getMap', async (req, res) => {
	try {
		const room = checkRoom(req.body.room)
		const doc = new Y.Doc()
		const wsProvider = new WebsocketProvider(websocket, `prsm${room}`, doc)
		wsProvider.on('synced', () => {
			const yNodesMap = doc.getMap('nodes')
			const yEdgesMap = doc.getMap('edges')
			const yNetMap = doc.getMap('network')

			res.json({
				room,
				title: yNetMap.get('mapTitle'),
				viewOnly: yNetMap.get('viewOnly'),
				version: yNetMap.get('version'),
				backgroundColor: yNetMap.get('backgroundColor'),
				nodes: stripArray(Array.from(yNodesMap.values()), ['id', 'borderWidth', 'created', 'label', 'x', 'y', 'color', 'font', 'groupLabel', 'grp', 'modified', 'shape']),
				edges: stripArray(Array.from(yEdgesMap.values()), ['id', 'from', 'to', 'label', 'color', 'dashes', 'width', 'arrows', 'groupLabel', 'grp', 'created', 'modified']),
			})
			doc.destroy()
		})
	} catch (error) {
		res.status(500).json({ error: error.message })
	}
})

const server = app.listen(PORT, () => {
	console.log(`Proxy server running on http://localhost:${PORT}`)
})

const httpTerminator = createHttpTerminator({ server });

// Graceful shutdown on Ctrl-C
process.on('SIGINT', () => {
	console.log('\nReceived SIGINT, shutting down...');
	httpTerminator.terminate().then(() => {
		console.log('HTTP server closed');
		process.exit(0);
	});
});

function checkRoom(room) {
	room = room.toUpperCase()
	if (!room || !room.match(/[A-Z]{3}-[A-Z]{3}-[A-Z]{3}-[A-Z]{3}/)) {
		throw new Error(`Invalid room identifier: ${room}`)
	}
	return room
}
/**
 * return a copy of an object that only includes the properties that are in allowed
 * @param {Object} obj the object to copy
 * @param {array} allowed list of allowed properties
 */
function strip(obj, allowed) {
	return allowed.reduce((a, e) => {
		a[e] = obj[e]
		return a
	}, {})
}
/**
 * return an array of objects, each stripped to only include the allowed properties
 * @param {array} arr 
 * @param {array} allowed 
 * @returns 
 */
function stripArray(arr, allowed) {
	return arr.map((item) => strip(item, allowed))
}