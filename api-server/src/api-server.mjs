/********************************server.js***********************
 * Express server that provides API access to a map
 *  and also acts as a proxy to the Bedrock API:
 * Exposes an endpoint /api/chat that accepts POST requests with a user message
 * and optional system prompt, forwards them to Bedrock, and returns the response.
 * 
 * Requires the following environment variables:
 * - BEDROCK_API_KEY: Your Bedrock API key
 * - AWS_REGION: AWS region where Bedrock is hosted (default: eu-west-2)
 * - MODEL_ID: Bedrock model ID to use (default: eu.anthropic.claude-haiku-4-5-20251001-v1:0)
 * These are obtained from the AWS Secrets Manager
 * 
 * Run this as a service: prsm-api-server.service:
 * 
 * /etc/systemd/system/prsm-api-server.service

for status, use:
journalctl -f -u prsm-api-server
****************************************************************
*
* or locally:
* npm run local
 ***************************************************************/

import express from 'express'
import cors from 'cors'
import { WebsocketProvider } from 'y-websocket'
import * as Y from 'yjs'
import { createHttpTerminator } from 'http-terminator'
import rateLimit from 'express-rate-limit'
import { loadSecrets } from './secrets.mjs'

process.title = 'api-server'

// use local websocket server if in development mode
let websocket = 'wss://www.prsm.uk/wss'
if (process.env.NODE_ENV === "dev") {
	console.log('Running in development mode')
	websocket = 'ws://localhost:1234'
}
const app = express()
const PORT = process.env.PORT || 3001
let room = '' // current room, set by middleware that checks the room parameter in incoming requests

// Rate limiting and concurrency control
const globalLimiter = rateLimit({
	windowMs: 60 * 1000, // 1 minute
	max: 60,            // 60 requests per minute per IP
	standardHeaders: true,
	legacyHeaders: false,
})

const ChatLimiter = rateLimit({
	windowMs: 60 * 1000, // 1 minute
	max: 5,             // 5 chat requests per minute per IP
	standardHeaders: true,
	legacyHeaders: false,
	message: {
		error: 'Too many chat requests, please slow down and try again shortly.',
	},
})
app.set('trust proxy', 1) // trust first proxy, if behind a proxy
let inFlightChatRequests = 0
const MAX_IN_FLIGHT_CHAT = 10

// Middleware
app.use(cors())
app.use(express.json())
app.use(globalLimiter)

// Check that all incoming requests have a valid room id., and note it for use in the handlers

app.all([
	'/api/chat/:room',
	'/api/map/:room',
	'/api/map/:room/factor/:factor',
	'/api/map/:room/link/:link',
	'/api/map/:room/styles',
	'/api/map/:room/styles/:style'
], (req, res, next) => {
	try {
		room = checkRoom(req.params.room)
		next()
	} catch (error) {
		res.status(500).json({ error: error.message })
	}
})
// Proxy endpoint for Bedrock chat
app.post('/api/chat/:room', ChatLimiter, async (req, res) => {
	// Bedrock configuration from environment variables
	const region = process.env.AWS_REGION || 'eu-west-2'
	const bedrockApiKey = process.env.BEDROCK_API_KEY
	const modelId = process.env.MODEL_ID || 'eu.anthropic.claude-haiku-4-5-20251001-v1:0'
	logAPICalls(`Using chat for room ${room}`)

	if (!bedrockApiKey) {
		console.error('ERROR: BEDROCK_API_KEY environment variable is not set')
		return res.status(500).json({ error: 'LLM API key is not set' })
	}

	if (inFlightChatRequests >= MAX_IN_FLIGHT_CHAT) {
		return res.status(503).json({ error: 'Server is busy, please retry later.' })
	}

	inFlightChatRequests += 1
	try {
		const { message, systemPrompt } = req.body
		if (!message) {
			return res.status(400).json({ error: 'Message is required' })
		}
		const conversation = [
			{
				role: 'user',
				content: [{ text: message }],
			},
		]
		const payload = {
			modelId,
			messages: conversation,
			system: [
				{
					text: `${systemPrompt}  ||
\t"> ***This text has been generated by AI. It needs to be checked carefully.***". 
\tFormat your answer using Markdown. `,
				},
			],
			inferenceConfig: { maxTokens: 512, temperature: 0.5 },
		}

		const url = `https://bedrock-runtime.${region}.amazonaws.com/model/${modelId}/converse`
		const response = await fetch(url, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				Authorization: `Bearer ${bedrockApiKey}`,
			},
			body: JSON.stringify(payload),
		})

		if (!response.ok) {
			const errorText = await response.text()
			console.error('Bedrock API error:', errorText)
			return res.status(response.status).json({ error: errorText })
		}

		const data = await response.json()
		const responseText = data.output.message.content[0].text

		res.json({ response: responseText })
	} catch (error) {
		console.error('Server error:', error)
		res.status(500).json({ error: error.message })
	} finally {
		inFlightChatRequests -= 1
	}
})

// Endpoints for API access to map data

/**
 * GET basic info about the map: title, background color, list of factors and links
 * Map must exist (i.e. have been created using the web interface)
 */
app.get('/api/map/:room', async (req, res) => {
	try {
		logAPICalls(`Fetching map for room ${room}`)
		const doc = new Y.Doc()
		const wsProvider = new WebsocketProvider(websocket, `prsm${room}`, doc)
		let sentResponse = false;
		wsProvider.on('synced', () => {
			if (!sentResponse) {
				try {
					const yNodesMap = doc.getMap('nodes')
					const yEdgesMap = doc.getMap('edges')
					const yNetMap = doc.getMap('network')
					checkMapExists(yNetMap)
					res.json({
						room,
						title: yNetMap.get('mapTitle'),
						viewOnly: yNetMap.get('viewOnly'),
						version: yNetMap.get('version'),
						background: yNetMap.get('background'),
						nodes: stripArray(Array.from(yNodesMap.values()), ['id', 'label', 'x', 'y']),
						edges: stripArray(Array.from(yEdgesMap.values()), ['id', 'from', 'to', 'label']),
					})
					sentResponse = true
				} catch (error) {
					res.status(500).json({ error: error.message })
					sentResponse = true
				} finally {
					doc.destroy()
					wsProvider.disconnect()
					wsProvider.destroy()
				}
			}
		})
	} catch (error) {
		res.status(500).json({ error: error.message })
	}
})

/**
 * UPDATE basic map info (title and background color)
 */
app.patch('/api/map/:room', async (req, res) => {
	try {
		logAPICalls(`Updating map for room ${room}`)
		const { update } = req.body

		if (!update) {
			return res.status(400).json({ error: 'Nothing provided for update' })
		}
		const doc = new Y.Doc()
		const wsProvider = new WebsocketProvider(websocket, `prsm${room}`, doc)
		let sentResponse = false;
		wsProvider.on('synced', () => {
			if (!sentResponse) {
				try {
					const yNetMap = doc.getMap('network')
					checkMapExists(yNetMap)
					if (update.title) {
						yNetMap.set('mapTitle', update.title)
					}
					if (update.background) {
						yNetMap.set('background', update.background)
					}
					res.json({
						room,
						title: yNetMap.get('mapTitle'),
						background: yNetMap.get('background'),
					})
					sentResponse = true
				} catch (error) {
					res.status(500).json({ error: error.message })
					sentResponse = true
				} finally {
					doc.destroy()
					wsProvider.disconnect()
					wsProvider.destroy()
				}
			}
		})
	} catch (error) {
		res.status(500).json({ error: error.message })
	}
})

/**
 * Return full details about a specific factor
 */
app.get('/api/map/:room/factor/:factor', async (req, res) => {
	try {
		logAPICalls(`Fetching factor ${req.params.factor} for room ${room}`)
		const doc = new Y.Doc()
		const wsProvider = new WebsocketProvider(websocket, `prsm${room}`, doc)
		let sentResponse = false;
		wsProvider.on('synced', () => {
			if (!sentResponse) {
				const yNodesMap = doc.getMap('nodes')
				const factorDetails = yNodesMap.get(req.params.factor)
				if (factorDetails && !sentResponse) {
					res.json(
						strip(factorDetails, ['id', 'label', 'x', 'y', 'borderWidth', 'color', 'created', 'modified', 'groupLabel', 'grp', 'font', 'shape', 'shapeProperties'])
					)
				} else {
					res.status(404).json({ error: 'Factor not found' })
				}
				sentResponse = true
				doc.destroy()
				wsProvider.disconnect()
				wsProvider.destroy()
			}
		})
	} catch (error) {
		res.status(500).json({ error: error.message })
	}
})

/**
 * Update properties of a specific factor
 * Body must include an 'update' object with the properties to update
 */
app.patch('/api/map/:room/factor/:factor', async (req, res) => {
	try {
		logAPICalls(`Updating factor ${req.params.factor} for room ${room}`)
		const { update } = req.body

		if (!update) {
			return res.status(400).json({ error: 'Nothing provided for update' })
		}

		const doc = new Y.Doc()
		const wsProvider = new WebsocketProvider(websocket, `prsm${room}`, doc)
		let sentResponse = false;
		wsProvider.on('synced', () => {
			if (!sentResponse) {
				const yNodesMap = doc.getMap('nodes')
				const oldFactor = yNodesMap.get(req.params.factor)
				if (oldFactor) {
					const newFactor = { ...deepUpdate(oldFactor, update), modified: { time: Date.now(), user: 'API' } }
					yNodesMap.set(req.params.factor, newFactor)
					res.json(
						strip(newFactor, ['id', 'label', 'x', 'y', 'borderWidth', 'color', 'created', 'modified', 'groupLabel', 'grp', 'font', 'shape', 'shapeProperties'])
					)
				} else {
					res.status(404).json({ error: 'Factor not found' })
				}
				sentResponse = true
				doc.destroy()
				wsProvider.disconnect()
				wsProvider.destroy()
			}
		})
	} catch (error) {
		res.status(500).json({ error: error.message })
	}
})

/**
 * Create a new factor with specified properties
 * Body must include a 'spec' object with the factor properties
 */
app.post('/api/map/:room/factor/:factor', async (req, res) => {
	try {
		logAPICalls(`Creating factor ${req.params.factor} for room ${room}`)
		const { spec } = req.body

		// validate spec: must have at least a label
		if (!spec) {
			return res.status(400).json({ error: 'Missing factor specification' })
		}
		if (!spec.label) {
			return res.status(400).json({ error: 'Missing factor label in spec.' })
		}
		const newFactor = {
			// default properties, which may be overwritten by spec.
			x: 0, y: 0, borderWidth: 0, color: {
				border: "rgb(154, 219, 180)",
				background: "rgb(154, 219, 180)",
				highlight: {
					border: "rgb(154, 219, 180)",
					background: "rgb(154, 219, 180)"
				},
				hover: {
					border: "rgb(154, 219, 180)",
					background: "rgb(154, 219, 180)"
				}
			}, font: {
				face: "Oxygen",
				color: "rgb(0, 0, 0)",
				size: 14
			}, grp: 0, shape: "box", shapeProperties: {}, ...spec,
			created: { time: Date.now(), user: 'API' },
			modified: { time: Date.now(), user: 'API' },
			id: req.params.factor
		}

		const doc = new Y.Doc()
		const wsProvider = new WebsocketProvider(websocket, `prsm${room}`, doc)
		let sentResponse = false;
		wsProvider.on('synced', () => {
			if (!sentResponse) {
				const yNodesMap = doc.getMap('nodes')
				yNodesMap.set(req.params.factor, newFactor)
				res.json(
					strip(newFactor, ['id', 'label', 'x', 'y', 'borderWidth', 'color', 'created', 'modified', 'groupLabel', 'grp', 'font', 'shape', 'shapeProperties'])
				)
			}
			sentResponse = true
			doc.destroy()
			wsProvider.disconnect()
			wsProvider.destroy()
		})
	} catch (error) {
		res.status(500).json({ error: error.message })
	}
})

/**
 * Delete a specific factor and all links to it
 */
app.delete('/api/map/:room/factor/:factor', async (req, res) => {
	try {
		logAPICalls(`Deleting factor ${req.params.factor} for room ${room}`)

		const doc = new Y.Doc()
		const wsProvider = new WebsocketProvider(websocket, `prsm${room}`, doc)
		let sentResponse = false;
		wsProvider.on('synced', () => {
			if (!sentResponse) {
				const yNodesMap = doc.getMap('nodes')
				const oldFactor = yNodesMap.get(req.params.factor)
				if (oldFactor) {
					// delete all links to this factor
					for (const [edgeId, edge] of doc.getMap('edges')) {
						if (edge.from === req.params.factor || edge.to === req.params.factor) {
							doc.getMap('edges').delete(edgeId)
						}
					}
					// then delete the factor
					yNodesMap.delete(req.params.factor)
					res.json({ message: 'Factor deleted' })
					sentResponse = true;
				} else {
					res.status(404).json({ error: 'Factor not found' })
				}
				sentResponse = true;
			}
			doc.destroy()
			wsProvider.disconnect()
			wsProvider.destroy()
		})
	} catch (error) {
		res.status(500).json({ error: error.message })
	}
})

/**
 * Return full details about a specific link
 */
app.get('/api/map/:room/link/:link', async (req, res) => {
	try {
		logAPICalls(`Fetching link ${req.params.link} for room ${room}`)
		const doc = new Y.Doc()
		const wsProvider = new WebsocketProvider(websocket, `prsm${room}`, doc)
		let sentResponse = false;
		wsProvider.on('synced', () => {
			if (!sentResponse) {
				const yEdgesMap = doc.getMap('edges')
				const linkDetails = yEdgesMap.get(req.params.link)
				if (linkDetails && !sentResponse) {
					res.json(
						strip(linkDetails, ['id', 'label', 'from', 'to', 'arrows', 'width', 'dashes', 'color', 'created', 'modified', 'groupLabel', 'grp', 'font'])
					)
				} else {
					res.status(404).json({ error: 'Link not found' })
				}
				sentResponse = true
				doc.destroy()
				wsProvider.disconnect()
				wsProvider.destroy()
			}
		})
	} catch (error) {
		res.status(500).json({ error: error.message })
	}
})

/**
 * Update properties of a specific link
 * Body must include an 'update' object with the properties to update
 */
app.patch('/api/map/:room/link/:link', async (req, res) => {
	try {
		logAPICalls(`Updating link ${req.params.link} for room ${room}`)
		const { update } = req.body

		if (!update) {
			return res.status(400).json({ error: 'Nothing provided for update' })
		}

		const doc = new Y.Doc()
		const wsProvider = new WebsocketProvider(websocket, `prsm${room}`, doc)
		let sentResponse = false;
		wsProvider.on('synced', () => {
			if (!sentResponse) {
				const yEdgesMap = doc.getMap('edges')
				const oldLink = yEdgesMap.get(req.params.link)
				if (oldLink) {
					const newLink = { ...deepUpdate(oldLink, update), modified: { time: Date.now(), user: 'API' } }
					yEdgesMap.set(req.params.link, newLink)
					res.json(
						strip(newLink, ['id', 'label', 'from', 'to', 'arrows', 'width', 'dashes', 'color', 'created', 'modified', 'groupLabel', 'grp', 'font'])
					)
				} else {
					res.status(404).json({ error: 'Link not found' })
				}
				sentResponse = true
				doc.destroy()
				wsProvider.disconnect()
				wsProvider.destroy()
			}
		})
	} catch (error) {
		res.status(500).json({ error: error.message })
	}
})

/**
 * Create a new link with specified properties
 * Body must include a 'spec' object with the link properties
 */
app.post('/api/map/:room/link/:link', async (req, res) => {
	try {
		logAPICalls(`Creating link ${req.params.link} for room ${room}`)
		const { spec } = req.body

		// validate spec: must have at least a from and to
		if (!spec) {
			return res.status(400).json({ error: 'Missing link specification' })
		}
		if (!spec.from || !spec.to) {
			return res.status(400).json({ error: 'Missing link endpoints in spec.' })
		}
		const newLink = {
			// default properties, which may be overwritten by spec.
			color: {
				color: "rgb(0,0,0)",
				highlight: "rgb(0,0,0)",
				hover: "rgb(0,0,0)"
			}, font: {
				face: "Oxygen",
				color: "rgb(0, 0, 0)",
				size: 14
			}, grp: 0,
			arrows: {
				to: {
					enabled: true,
					type: "vee"
				},
				middle: {
					enabled: false
				},
				from: {
					enabled: false
				},
			},
			dashes: false,
			...spec,
			created: { time: Date.now(), user: 'API' },
			modified: { time: Date.now(), user: 'API' },
			id: req.params.link
		}

		const doc = new Y.Doc()
		const wsProvider = new WebsocketProvider(websocket, `prsm${room}`, doc)
		let sentResponse = false;
		wsProvider.on('synced', () => {
			if (!sentResponse) {
				const yNodesMap = doc.getMap('nodes')
				const edgesMap = doc.getMap('edges')
				// also ensure that the nodes exist
				if (!yNodesMap.has(newLink.from) || !yNodesMap.has(newLink.to)) {
					res.status(400).json({ error: 'One or both link endpoints do not exist as factors.' })
				} else {
					edgesMap.set(req.params.link, newLink)
					res.json(
						strip(newLink, ['id', 'label', 'from', 'to', 'arrows', 'width', 'dashes', 'color', 'created', 'modified', 'groupLabel', 'grp', 'font']))
				}
			}
			sentResponse = true
			doc.destroy()
			wsProvider.disconnect()
			wsProvider.destroy()
		})
	} catch (error) {
		res.status(500).json({ error: error.message })
	}
})

/**
 * Delete a specific link
 */
app.delete('/api/map/:room/link/:link', async (req, res) => {
	try {
		logAPICalls(`Deleting link ${req.params.link} for room ${room}`)

		const doc = new Y.Doc()
		const wsProvider = new WebsocketProvider(websocket, `prsm${room}`, doc)
		let sentResponse = false;
		wsProvider.on('synced', () => {
			if (!sentResponse) {
				const yEdgesMap = doc.getMap('edges')
				const oldLink = yEdgesMap.get(req.params.link)
				if (oldLink) {
					yEdgesMap.delete(req.params.link)
					res.json({ message: 'Link deleted' })
				} else {
					res.status(404).json({ error: 'Link not found' })
				}
				sentResponse = true;
			}
			doc.destroy()
			wsProvider.disconnect()
			wsProvider.destroy()
		})
	} catch (error) {
		res.status(500).json({ error: error.message })
	}
})
/**
 *  Return a list of all styles (colors, fonts, shapes) used in the map, for factors and links.
 */
app.get('/api/map/:room/styles', async (req, res) => {
	try {
		logAPICalls(`Fetching styles for room ${room}`)
		const doc = new Y.Doc()
		const wsProvider = new WebsocketProvider(websocket, `prsm${room}`, doc)
		let sentResponse = false;
		wsProvider.on('synced', () => {
			if (!sentResponse) {
				const ySamplesMap = doc.getMap('samples')
				const styles = Array.from(ySamplesMap.entries()).filter(style => /^[edge|group]/.test(style[0]))
				console.log(styles)
				res.json(styles)
				sentResponse = true
				doc.destroy()
				wsProvider.disconnect()
				wsProvider.destroy()
			}
		})
	} catch (error) {
		res.status(500).json({ error: error.message })
	}
})

/**
 *  Return the info for the given style.
 */
app.get('/api/map/:room/styles/:style', async (req, res) => {
	try {
		logAPICalls(`Fetching styles for room ${room}`)
		const doc = new Y.Doc()
		const wsProvider = new WebsocketProvider(websocket, `prsm${room}`, doc)
		let sentResponse = false;
		wsProvider.on('synced', () => {
			if (!sentResponse) {
				const ySamplesMap = doc.getMap('samples')
				const style = ySamplesMap.get(req.params.style)
				if (style) {
					res.json([req.params.style, style])
					sentResponse = true
				} else {
					res.status(404).json({ error: 'Style not found' })
				}
				doc.destroy()
				wsProvider.disconnect()
				wsProvider.destroy()
			}
		})
	} catch (error) {
		res.status(500).json({ error: error.message })
	}
})

app.patch('/api/map/:room/styles/:style', async (req, res) => {
	try {
		logAPICalls(`Updating style ${req.params.style} for room ${room}`)
		const { update } = req.body

		if (!update) {
			return res.status(400).json({ error: 'Nothing provided for update' })
		}

		const doc = new Y.Doc()
		const wsProvider = new WebsocketProvider(websocket, `prsm${room}`, doc)
		let sentResponse = false;
		wsProvider.on('synced', () => {
			if (!sentResponse) {
				const yStylesMap = doc.getMap('samples')
				const oldStyle = yStylesMap.get(req.params.style)
				if (oldStyle) {
					const newStyle = deepUpdate(oldStyle, update)
					yStylesMap.set(req.params.style, newStyle)
					res.json(newStyle)
				} else {
					res.status(404).json({ error: 'Style not found' })
				}
				sentResponse = true
				doc.destroy()
				wsProvider.disconnect()
				wsProvider.destroy()
			}
		})
	} catch (error) {
		res.status(500).json({ error: error.message })
	}
})
let server // server instance
let httpTerminator // terminator instance
/**
 * Start the server after loading secrets
 */
async function start() {
	// Load secrets first
	await loadSecrets();

	// Start the server
	server = app.listen(PORT, () => {
		console.log(`Proxy server running on http://localhost:${PORT} using websocket server at ${websocket}`)
	})
	httpTerminator = createHttpTerminator({ server });
}
start();

/****** Utilities  ************/

// Graceful shutdown on Ctrl-C
process.on('SIGINT', () => {
	console.log('\nReceived SIGINT, shutting down...');
	httpTerminator.terminate().then(() => {
		console.log('HTTP server closed');
		process.exit(0);
	});
});
/**
 * Check that a room identifier is properly formed
 * @param {string} room 
 * @returns {string} room in uppercase if valid
 * @throws {Error} if room is invalid
 */
function checkRoom(room) {
	room = room.toUpperCase()
	if (!room || !room.match(/[A-Z]{3}-[A-Z]{3}-[A-Z]{3}-[A-Z]{3}/)) {
		throw new Error(`Invalid room identifier: ${room}`)
	}
	return room
}
/**
 * Check that a map has been created using the web interface
 * Since there is no way to list existing Yjs documents on the server,
 * we check for the presence of the 'lastLoaded' property in the network map
 * @param {Y.Map} yNetMap 
 */
function checkMapExists(yNetMap) {
	const lastLoaded = yNetMap.get('lastLoaded')
	if (!lastLoaded) {
		throw new Error('Map not found')
	}
}
/**
 * time stamp and output message to console
 * @param {string} message 
 */
function logAPICalls(message) {
	const timestamp = new Date().toLocaleString()
	console.log(`[${timestamp}] ${message}`)
}

// utility functions
/**
 * Recursively updates properties in a target object with values from an update object.
 * Searches deeply through nested objects to find and update matching keys.
 * Only updates keys that already exist in the target object; it does not add new keys.
 * Stops as soon as a match is found and updated, so if there are multiple nested objects 
 * with the same key, only the first one encountered will be updated.
 * 
 * @param {Object} target - The object to update
 * @param {Object} updates - Object containing key-value pairs to update
 * @returns {Object} The updated target object
 */
function deepUpdate(target, updates) {
	for (const [key, value] of Object.entries(updates)) {
		if (Object.hasOwn(target, key)) {
			target[key] = value;
		} else {
			// Search nested objects, stopping at first match
			for (const prop in target) {
				if (typeof target[prop] === 'object' && target[prop] !== null) {
					if (Object.hasOwn(target[prop], key)) {
						target[prop][key] = value;
						break; // Stop after first match
					}
					// Recursively search deeper if not found at this level
					deepUpdate(target[prop], { [key]: value });
				}
			}
		}
	}
	return target;
}
/**
 * return a copy of an object that only includes the properties that are in allowed
 * @param {Object} obj the object to copy
 * @param {array} allowed list of allowed properties
 */
function strip(obj, allowed) {
	return allowed.reduce((a, e) => {
		a[e] = obj[e]
		return a
	}, {})
}
/**
 * return an array of objects, each stripped to only include the allowed properties
 * @param {array} arr 
 * @param {array} allowed 
 * @returns 
 */
function stripArray(arr, allowed) {
	return arr.map((item) => strip(item, allowed))
}