<!DOCTYPE html>
<html lang="en">
	<head>
		<title>PRSM: VR</title>
		<meta
			name="Description"
			content="PRSM enables groups of people, each using their own computer (or tablet) 
		to collaborate in the drawing of a map. They may be sitting around a table, discussing the map as it is 
		created face to face, or working remotely, using video conferencing or the chat feature that is built 
		into the app. Everyone can participate because every edit (creating nodes and links, arranging them 
		and so on) is broadcast to all the other participants as the changes are made (just as Google Docs 
		does for text, for example). When you start PRSM in your browser, a 'room' is created for you in which 
		to draw your network. You can add other users to this room to share the work. Only those with access 
		to the room can see what is being created."
		/>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=0, shrink-to-fit=no"
		/>
		<link rel="icon" type="image/png" sizes="32x32" href="../icons/favicon-32x32.png" />
		<link rel="icon" type="image/png" sizes="16x16" href="../icons/favicon-16x16.png" />
		<link rel="shortcut icon" href="../icons/favicon.ico" />
		<link rel="apple-touch-icon" sizes="180x180" href="../icons/apple-touch-icon.png" />
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black" />
		<!-- Basic A-Frame code -->
		<script src="../node_modules/aframe/dist/aframe-v1.3.0.min.js"></script>
		<!-- 		Follow gaze code -->
		<script src="../node_modules/aframe-look-at-component/dist/aframe-look-at-component.min.js"></script>
		<!-- 		Move around using controllers code -->
		<script src="../node_modules/aframe-extras/dist/aframe-extras.controls.min.js"></script>
		<!-- 		Layout graph code -->
		<script src="../node_modules/aframe-forcegraph-component/dist/aframe-forcegraph-component.min.js"></script>
		<script src="../js/aframe-html.min.js"></script>
		<!-- 		Interace with yjs to get nodes and links code -->
		<script src="https://supereggbert.github.io/aframe-htmlembed-component/dist/build.js"></script>
		<script src="../js/vr.js" type="module"></script>
		<!-- 		Components to provide special features -->
		<script>
			/*
			 * Given a CSS color string, return the hex equivalent
			 * @param {string} color
			 * @return {string}
			 */
			function standardize_color(str) {
				if (!str) return '#000000'
				if (str.charAt(0) === '#') return str
				let ctx = document.createElement('canvas').getContext('2d')
				ctx.fillStyle = str
				return ctx.fillStyle
			}
			/*
			 * Test whether color is light or dark
			 * @param {string} hex color code
			 * @return {string} 'light' or 'dark'
			 */

			function lightOrDark(color) {
				color = standardize_color(color)
				// Convert it to RGB: http://gist.github.com/983661
				color = +('0x' + color.slice(1).replace(color.length < 5 && /./g, '$&$&'))

				let r = color >> 16
				let g = (color >> 8) & 255
				let b = color & 255

				// HSP (Highly Sensitive Poo) equation from http://alienryderflex.com/hsp.html
				let hsp = Math.sqrt(0.299 * (r * r) + 0.587 * (g * g) + 0.114 * (b * b))

				return hsp > 127.5 ? 'light' : 'dark'
			}
			/**
			 * divide txt into lines to make it roughly square, with a
			 * maximum width of width characters, but not breaking words and
			 * respecting embedded line breaks (\n).
			 * @param {string} txt
			 * @param {number} width
			 */
			function splitText(txt, width) {
				let lines = ''
				let chunks = txt.trim().split('\n')
				chunks.forEach((chunk) => {
					let words = chunk.trim().split(/\s/)
					let nChars = chunk.trim().length
					if (nChars > 2 * width) width = Math.floor(Math.sqrt(nChars))

					for (let i = 0, linelength = 0; i < words.length; i++) {
						lines += words[i]
						if (i == words.length - 1) break
						linelength += words[i].length
						if (linelength > width) {
							lines += '\n'
							linelength = 0
						} else lines += ' '
					}
					lines += '\n'
				})
				return lines.trim()
			}
			/**
			 * Billboard component.
			 *
			 * Rotates the entity to face the current camera
			 * https://github.com/blairmacintyre/aframe-look-at-billboard-component/blob/master/index.js
			 */
			AFRAME.registerComponent('billboard', {
				init: function () {
					this.vector = new THREE.Vector3()
				},

				tick: function (t) {
					var self = this
					var target = self.el.sceneEl.camera
					var object3D = self.el.object3D

					// make sure camera is set
					if (target) {
						target.updateMatrixWorld()
						this.vector.setFromMatrixPosition(target.matrixWorld)
						if (object3D.parent) {
							object3D.parent.updateMatrixWorld()
							object3D.parent.worldToLocal(this.vector)
						}
						return object3D.lookAt(this.vector)
					}
				},
			})
			/* helper for vasturiano/3d-force-graph-vr
			 *			draw a sphere around each force graph node, to make it easy to point to them with the ray caster,
			 * 			and attach a text label (which rotates to always face the camera)
			 * after the graph has been created, use something like
			 *			fgEl.setAttribute('spherize', {})
			 * to create the spheres
			 */
			AFRAME.registerComponent('spherize', {
				schema: {},
				dependencies: ['forcegraph'],
				init: function () {
					// spheres are cached here and re-used
					this.spheres = new Map()
				},
				tick: function (time, timeDelta) {
					document
						.querySelector('[forcegraph]')
						.components.forcegraph.forceGraph.children.forEach((child) => {
							if (child.type == 'Mesh' && child.__data.id) {
								let sphereEl = this.spheres.get(child.__data.id)
								if (sphereEl && document.getElementById(child.__data.id)) {
									// reuse existing sphere and label, but change its position
									sphereEl.object3D.position.copy(child.position)
								} else {
									sphereEl = document.createElement('a-sphere')
									sphereEl.classList.add('node')
									sphereEl.id = child.__data.id
									this.spheres.set(child.__data.id, sphereEl)
									sphereEl.setAttribute('position', child.position)
									let radius = child.geometry.parameters.radius + 0.1
									sphereEl.setAttribute('radius', radius)
									let color = child.__data.color || 'white'
									let compColor = lightOrDark(standardize_color(color)) == 'light' ? 'black' : 'white'
									sphereEl.setAttribute('color', color)
									sphereEl.setAttribute('note', child.__data.note)
									this.el.appendChild(sphereEl)

									let label = document.createElement('a-entity')
									label.setAttribute('text', {
										value: splitText(child.__data.label, 9),
										color: compColor,
										width: 5 * radius,
										align: 'center',
									})
									sphereEl.setAttribute('look-at', '#cameraRig')
									label.setAttribute('position', {x: 0, y: 0, z: radius})
									sphereEl.appendChild(label)

									sphereEl.addEventListener('mouseenter', function () {
										let noteText = sphereEl.getAttribute('note')
										if (!noteText) return
										/* let noteDiv = document.createElement('div')
										noteDiv.id = 'noteDiv'
										noteDiv.innerHTML = noteText
										sphereEl.appendChild(noteDiv) */
										let note = document.createElement('a-entity')
										sphereEl.appendChild(note)
/* 										note.setAttribute('html', {html: '#noteDiv'})
 */										note.id = 'note'
										

/* 										note.setAttribute('text', {
											value: noteText,
											color: 'black',
											width: 20,
											anchor: 'left',
											align: 'left',
										}) */
										note.setAttribute('htmlembed', {
											ppu: 256
										})
										note.innerHTML = noteText
//										note.setAttribute('geometry', {primitive: 'plane', height: 'auto', width: 20})
//										note.setAttribute('material', {color: 'grey'})
										note.setAttribute('scale', {x: 40, y: 40, z: 40})
										note.setAttribute('position', {x: radius + 1, y: 0, z: radius + 1})
										console.log('mouseenter')
									})
									sphereEl.addEventListener('mouseleave', function () {
										let note = sphereEl.querySelector('#note')
										if (note) sphereEl.removeChild(note)
										console.log('mouseleave')
									})
								}
							}
						})
				},
			})
			/*
			 * prevent the camera from entering a 3d entity
			 * coded by Synn ( https://github.com/chabloz )
			 */
			AFRAME.registerComponent('sphere-collider-constraint', {
				schema: {
					selector: {
						default: '',
					},
					distance: {
						default: 0.5,
					},
				},

				init: function () {
					//'this' is the cameraRig
					this.lastPosition = new THREE.Vector3()
					this.el.object3D.getWorldPosition(this.lastPosition)

					this.myPos = new THREE.Vector3()
					this.el.object3D.getWorldPosition(this.myPos)

					this.targetPos = new THREE.Vector3()
				},

				tick: function () {
					// if haven't moved since last tick, do nothing
					this.el.object3D.getWorldPosition(this.myPos)
					if (this.myPos.distanceTo(this.lastPosition) === 0) return

					let didHit = false

					for (const obj of document.querySelectorAll(this.data.selector)) {
						obj.object3D.getWorldPosition(this.targetPos)
						const distanceTo = this.myPos.distanceTo(this.targetPos)
						if (distanceTo <= this.data.distance + Number(obj.getAttribute('radius'))) {
							didHit = true
							break
						}
					}
					if (didHit) {
						this.el.object3D.position.copy(this.lastPosition)
						this.el.object3D.parent.worldToLocal(this.el.object3D.position)
					} else {
						this.el.object3D.getWorldPosition(this.lastPosition)
					}
				},
			})
			/*
			 * when the entity is clicked, the camera (and rig) is returned to the origin
			 */
			AFRAME.registerComponent('return-to-origin', {
				init: function () {
					let el = this.el
					el.addEventListener('click', function (e) {
						let cameraRig = document.querySelector('#cameraRig')
						cameraRig.setAttribute('position', {x: 0, y: 0, z: 0})
						cameraRig.setAttribute('rotation', {x: 0, y: 0, z: 0})
						let controls = document.querySelector('a-camera').components['look-controls']
						controls.pitchObject.rotation.x = 0
						controls.yawObject.rotation.y = 0
					})
				},
			})
		</script>
	</head>
	<body>
		<a-scene fog="type: linear; color: #D0ECE7">
			<!-- instructions -->
			<a-entity
				id="info"
				position="1 2 -2"
				billboard
				text="width: 2; lineHeight: 50; letterSpacing: 5; color: indigo; value: 
				Use the right hand controller to point to Factors and show their labels.\n
				Use the left hand thumb stick to go forwards, back, left or right relative to the direction in which you are looking.\n
				Point at the white ball at the origin (where the red, green and blue axes cross) and pull the trigger to jump straight there."
			></a-entity>
			<!-- force graph -->
			<a-entity id="fg"></a-entity>
			<!-- camera -->
			<a-entity
				id="cameraRig"
				movement-controls="fly: true; speed: 0.7"
				sphere-collider-constraint="selector: .node"
			>
				<a-camera id="camera" look-controls="pointerLockEnabled: true" wasd-controls="fly: true">
					<a-cursor color="#FF0000" raycaster="objects: #origin-box, .node"></a-cursor>
				</a-camera>

				<a-entity
					id="left-hand"
					hand-tracking-controls="hand: left"
					laser-controls="hand: left"
					raycaster="showLine: true; lineColor: green; objects: #origin-box, .node"
				></a-entity>
				<a-entity
					id="right-hand"
					laser-controls="hand: right"
					hand-tracking-controls="hand: right"
					raycaster="showLine: true; lineColor: green; objects: #origin-box, .node"
				></a-entity>
			</a-entity>
			<!-- centre point and axes -->
			<a-entity id="origin">
				<a-sphere
					id="origin-box"
					return-to-origin
					material="transparent: true; opacity: 0"
					radius="8"
					position="0 0 0"
				></a-sphere>
				<a-sphere color="lightgray" radius="0.05"></a-sphere>
				<a-entity line="start: -500 0 0; end: 500 0 0; color: red"></a-entity>
				<a-entity line="start: 0 -500 0; end: 0 500 0; color: green"></a-entity>
				<a-entity line="start: 0 0 -500; end: 0 0 500; color: blue"></a-entity>
			</a-entity>
			<!-- sky -->
			<a-sky color="white"></a-sky>
			<!-- <a-entity position="0 1.6 -1" html="html:#noteDiv">
			</a-entity> -->
			<script>
										let note = document.createElement('a-entity')
										document.querySelector('a-scene').appendChild(note)
										note.setAttribute('html', {html: '#noteDiv'})
										note.id = 'note'
										note.setAttribute('position', {x: 0, y: 1.6, z: -1})

			</script>
		</a-scene>
		<div id="noteDiv"><p>This is some <strong>bold</strong> text<br><br>Some more </p></div>
	</body>
</html>
